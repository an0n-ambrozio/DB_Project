{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/an0n-ambrozio/Documents/an0n-ambrozio/database-design/DB_Project/app/api/candidate-profile/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { PrismaClient } from '@prisma/client';\nimport { cookies } from 'next/headers';\nimport jwt from 'jsonwebtoken';\n\nconst prisma = new PrismaClient();\nconst JWT_SECRET = process.env.JWT_SECRET || 'secret';\n\nasync function getUserFromToken() {\n    const cookieStore = await cookies();\n    const token = cookieStore.get('auth_token');\n\n    if (!token) return null;\n\n    try {\n        const decoded = jwt.verify(token.value, JWT_SECRET) as { userId: number, email: string, role: string };\n        return decoded;\n    } catch {\n        return null;\n    }\n}\n\nexport async function GET() {\n    const user = await getUserFromToken();\n    if (!user) {\n        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    // specific for candidate view\n    if (user.role !== 'candidate') {\n        // If not candidate, maybe return error or empty? \n        // But requested is \"candidate view\", so we assume calling this is for candidate profile\n        return NextResponse.json({ error: 'Access denied' }, { status: 403 });\n    }\n\n    const candidate = await prisma.candidate.findUnique({\n        where: { userId: user.userId },\n        include: { skills: true }\n    });\n\n    return NextResponse.json(candidate);\n}\n\nexport async function PUT(request: Request) {\n    const user = await getUserFromToken();\n    if (!user || user.role !== 'candidate') {\n        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const body = await request.json();\n    const { name, phone, skills } = body;\n\n    // Update candidate\n    const updatedCandidate = await prisma.candidate.update({\n        where: { userId: user.userId },\n        data: {\n            name,\n            phone,\n            // Simple skill update logic (delete all and recreate for simplicity or careful merge)\n            skills: {\n                deleteMany: {},\n                create: skills.map((s: string) => ({ skillName: s }))\n            }\n        },\n        include: { skills: true }\n    });\n\n    return NextResponse.json(updatedCandidate);\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,SAAS,IAAI,6IAAY;AAC/B,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAE7C,eAAe;IACX,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,QAAQ,YAAY,GAAG,CAAC;IAE9B,IAAI,CAAC,OAAO,OAAO;IAEnB,IAAI;QACA,MAAM,UAAU,kJAAG,CAAC,MAAM,CAAC,MAAM,KAAK,EAAE;QACxC,OAAO;IACX,EAAE,OAAM;QACJ,OAAO;IACX;AACJ;AAEO,eAAe;IAClB,MAAM,OAAO,MAAM;IACnB,IAAI,CAAC,MAAM;QACP,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAe,GAAG;YAAE,QAAQ;QAAI;IACtE;IAEA,8BAA8B;IAC9B,IAAI,KAAK,IAAI,KAAK,aAAa;QAC3B,kDAAkD;QAClD,wFAAwF;QACxF,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAgB,GAAG;YAAE,QAAQ;QAAI;IACvE;IAEA,MAAM,YAAY,MAAM,OAAO,SAAS,CAAC,UAAU,CAAC;QAChD,OAAO;YAAE,QAAQ,KAAK,MAAM;QAAC;QAC7B,SAAS;YAAE,QAAQ;QAAK;IAC5B;IAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;AAC7B;AAEO,eAAe,IAAI,OAAgB;IACtC,MAAM,OAAO,MAAM;IACnB,IAAI,CAAC,QAAQ,KAAK,IAAI,KAAK,aAAa;QACpC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAe,GAAG;YAAE,QAAQ;QAAI;IACtE;IAEA,MAAM,OAAO,MAAM,QAAQ,IAAI;IAC/B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG;IAEhC,mBAAmB;IACnB,MAAM,mBAAmB,MAAM,OAAO,SAAS,CAAC,MAAM,CAAC;QACnD,OAAO;YAAE,QAAQ,KAAK,MAAM;QAAC;QAC7B,MAAM;YACF;YACA;YACA,sFAAsF;YACtF,QAAQ;gBACJ,YAAY,CAAC;gBACb,QAAQ,OAAO,GAAG,CAAC,CAAC,IAAc,CAAC;wBAAE,WAAW;oBAAE,CAAC;YACvD;QACJ;QACA,SAAS;YAAE,QAAQ;QAAK;IAC5B;IAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;AAC7B"}}]
}